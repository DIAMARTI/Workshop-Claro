<h1>OpenShift Dia 4</h1>

<p>
<strong>Meta:</strong>
<br>Conocer el flujo de trabajo de openshift
</p>
<p>
<strong>Objetivos:</strong>
<br>- Automatizar el despliegue de aplicaciones con openshift
</p>
<p>
<strong>Secciones:</strong>
<br>- Gesti√≥n aplicaciones
</p>
<p>
<strong>Laboratorios:</strong>
<br><strong>-Explorando Templates</strong>
<br><strong>-Despliegue de middleware con contenido desde un git</strong>
<br><strong>-Despliegue de middleware con aplicaciones incluidas</strong>
<br><strong>-Despliegue de aplicaciones en cluster</strong>


</p>

<strong>Requisitos:</strong>
<br><strong>- Satellite</strong>
<br><strong>- RHEL client</strong>

<h3><br><strong>## Explorando templates</strong></h3>

<p align="left"><img src="https://github.com/workshopopennova/workshopclaro/raw/main/images/os023.png?raw=true?raw=true"></p>

Los templates permiten desplegar aplicaciones de forma rapida a traves del uso de parametros predefinidos, para ello primero nos logueamos al proyecto database0X y listamos los templates disponibles en la infraestrutura que coincidan con mariadb

<br>`# oc project database08`
<br>`# oc get template -n openshift | grep mariadb`

Para el primer ejemplo exploramos el template de mariadb que no es persistente por default
<br>`# oc describe template -n openshift mariadb-ephemeral`

Tambien podemos exportar el template a un archivo de texto que facilite su revision
<br>`# oc get template -n openshift mariadb-ephemeral -o yaml > template01.yaml`

Exploramos el template y sus variables, al menos revisemos las variables mas importan,tes, siendo estas
<br>MYSQL_USER
<br>MYSQL_PASSWORD
<br>MYSQL_DATABASE
<br>DATABASE_SERVICE_NAME

Con las variables identificadas, podemos crear un despliegue con el comando
<br>`# oc new-app --template=mariadb-ephemeral --param=MYSQL_USER=admin --param=MYSQL_PASSWORD=redhat --param=MYSQL_DATABASE=mariadb --param=DATABASE_SERVICE_NAME=mariadb`

En caso de no tener errores publicamos la aplicacion con
<br>`# oc expose service/mariadb`

Una vez finalizado el despliegue, examinamos los pods
<br>`# oc get pods`

Hacemos una sesion al pod que no sea deploy o build
<br>`# oc rsh <pod>`

Hacemos algunas consultas mysql
<br>`mysql -u root`
<br>`show databases;`
<br>`exit`
<br>`exit`

Borramos el despliegue actual con los comandos
<br>`# oc delete all --all`
<br>`# oc delete secret mariadb`

Si volvemos a explorar el template, notamos que la imagen de mariadb esta basada en RHEL8, pero podemos cambiarla a una basada en RHEL7
<br>`# oc new-app --template=mariadb-ephemeral --param=MYSQL_USER=admin --param=MYSQL_PASSWORD=redhat --param=MYSQL_DATABASE=mariadb --param=DATABASE_SERVICE_NAME=mariadb --param=MARIADB_VERSION=10.3-el7`

Examinamos el despliegue y recuperamos los recursos con
<br>`# oc delete all --all`
<br>`# oc delete secret mariadb`

<h3><br><strong>## Laboratorio 01</strong></h3>
<br> - Exporte el template de mariadb-ephemeral en un archivo .yaml el cual examinara para identificar las variables
<br> - Despliegue el template de mariadb-ephemeral en su proyecto database0X
<br> - Recuepere los recursos con los comandos # oc delete all --all # oc delete secret mariadb
<br> - Despliegue el template de mariadb-ephemeral en su proyecto database0X tomando como imagen base el sistema RHEL7
<br> - Recuepere los recursos con los comandos # oc delete all --all # oc delete secret mariadb

<h3><br><strong>## Almacenamiento persistente</strong></h3>

<p align="left"><img src="https://github.com/workshopopennova/workshopclaro/raw/main/images/os024.png?raw=true?raw=true"></p>

Para desplegar aplicaciones con la opcion de almacenamiento persistente, primero debemos contar con un recurso de almacenamiento compartido, en este caso podemos examinar los recursos NFS remotos disponibles para el alumno0X, cada alumno tiene recursos NFS remotos desde el pvX1 hasta el pvX9, en este ejemplo crearemos el recurso pvX1

<br>`# sudo mkdir /tmp/pv81`
<br>`# sudo mount -o,ro 192.168.10.130:/nfs/pv81 /tmp/pv81`
<br>`# sudo df -h`

Ahora que validamos que si contamos con acceso NFS al recurso pvX1 podemos crear un archivo que permita configurar un PV (recuerde cambiar los parametros unicos)

<br>`# vi pv81.yaml`
```
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv81
spec:
  capacity:
    storage: 100Mi
  accessModes:
  - ReadWriteMany
  nfs:
    path: /nfs/pv81
    server: 192.168.10.130
```

Ahora creamos el PV con el comando
<br>`# oc create -f pv81.yaml`

Como la accion de crear un PV es una accion administrativa, no tendremos permiso para crearlo, por ello el instructor habilito el comando oc_create_pv para esta operacion
<br>`# oc_create_pv pv81.yaml`

El comando oc_create_pv desloguea al usuario actual, por lo tanto si desea seguir ejecutando comandos OC vuelva a loguearse a la plataforma con oc login -u alumno0X

Para verificar la creacion del PV ejecute
<br>`# oc get pv`

Al igual que la creacion del PV, listar los PV son comandos administrativos, por ello el instructor habilito el comando oc_list_pv
<br>`# oc_list_pv`

El comando oc_list_pv desloguea al usuario actual, por lo tanto si desea seguir ejecutando comandos OC vuelva a loguearse a la plataforma con oc login -u alumno0X

En caso fallara en la creacion de un PV, solicite al instructor borrar el PV creado de forma incorrecta o utilice sus otros recursos pvX

Con un PV creado, ya puede crear un PVC que utilice el recurso PV creado, esta accion no es administrativa, asi que puede ejecutarse en su proyecto directamente, para ello primero cree el archivo pvc.yaml, recuerde cambiar los parametros unicos

<br>`# vi pvc81.yaml`
```
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc81
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
  volumeName: pv81
```

Proceda con la creacion del pvc
<br>`# oc create -f pvc81.yaml`

Valide la creacion del pvc pasando del estado Pending al estado Bound
<br>`# oc get pvc`

Tambien puede validar que el PV y PVC esten asociados a su proyecto con el comando
<br>`# oc_list_pv`

El comando oc_list_pv desloguea al usuario actual, por lo tanto si desea seguir ejecutando comandos OC vuelva a loguearse a la plataforma con oc login -u alumno0X

Ahora con el PVC listo podemos crear un POD con la imagen de mysql:5.7 disponible desde el ftp del salon
<br>`# wget ftp://192.168.10.190/openshift/mysql.tar`
<br>`# podman load *i mysql.tar`
<br>`# podman images`

Cargamos la imagen de mysql:5.7 en nuestro espacio de trabajo
<br>`# oc import-image docker.io/library/mysql:5.7 --confirm`
<br>`# oc get is`

Ahora podemos crear el archivo de pod llamado mysql
<br>`# vi mysql.yaml`
```
apiVersion: v1
kind: Pod
metadata:
  name: mysql
  labels:
    name: mysql
spec:
  containers:
    - resources:
        limits :
          cpu: 0.5
      image: mysql:5.7
      name: mysql
      env:
        - name: MYSQL_ROOT_PASSWORD
          value: redhat
        - name: MYSQL_USER
          value: admin
        - name: MYSQL_PASSWORD
          value: redhat
        - name: MYSQL_DATABASE
          value: samples
      ports:
        - containerPort: 3306
          name: mysql
      volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
  volumes:
    - name: mysql-persistent-storage
      persistentVolumeClaim:
        claimName: pvc81
```
Notemos que el pod se define con almacenamiento persistente en /var/lib/mysql con el pvc81 que fue creado en pasos previos, creamos el pod con
<br>`# oc create -f mysql.yaml`

Con el pod creados podemos crear el servicio con
<br>`# vi service.yaml`
```
apiVersion: v1
kind: Service
metadata:
  labels:
    name: mysql
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    name: mysql
```
<br>`# oc create -f service.yaml`
<br>`# oc expose service mysql`

Con el servicio expuesto podemos examinar el pod con el usuario root y la clave redhat
<br>`# oc rsh mysql`
<br>`$ mysql -u root -p`
<br>`$ mysql> create database test01;`
<br>`$ mysql> create database test02;`
<br>`$ mysql> create database test03;`
<br>`$ exit;`
<br>`# exit;`

Validamos la data dentro de la carpeta /tmp/pv81
<br>`# ls /tmp/pv81;`

Ahora que verificamos la persistencia de la data, destruimos todos los recursos de openshift
<br>`# oc delete all --all;`

Intentamos crear de nuevo los recursos de imagen, pod, servicio y route
<br>`# oc import-image docker.io/library/mysql:5.7 --confirm`
<br>`# oc create -f mysql.yaml`
<br>`# oc create -f service.yaml`
<br>`# oc expose service mysql`

Verificamos la disponibilidad de las bases de datos creadas en pasos anteriores con el usuario root y la clave redhat<br>`# oc expose service mysql`
<br>`# oc rsh mysql`
<br>`$ show databases;`
<br>`$ exit`
<br>`# exit`

Eliminamos los recursos con
<br>`# oc delete all -all`

<h3><br><strong>## Laboratorio 02</strong></h3>
<br> - Utilizando los recursos en el ftp del salon, importe la imagen de mysql en version 5.7 en su espacio de trabajo
<br> - Usando los archivos .yaml de ejemplo, cree un servicio mysql persistente, recuerde usar su propia numeracion de recursos basado en pvX1-9 donde X es su numero de alumno
<br> - En caso se equivoque en crear algun recurso de PV y desee reahacerlo, use los demas recursos NFS disponibles o solicite a su instructor ayuda para borrar el recurso mal creado
<br> - Cree algunas bases de datos de ejemplo
<br> - Borre el pod, service y route de su proyecto e intente re-desplegarlo y verifique la persistentica de los datos
<br> - Al final del ejercicio borre los recursos con el coman oc delete all --all




<br>
<br>
<br>
<h3><a href="os">Volver</a></h3>
